{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>let's F#%K around and find out ^^</p>"},{"location":"#intro","title":"Intro","text":"<p>Hi, I'm a Software Engineer passionate about breaking things and then rebuilding them from ashes.</p>"},{"location":"#my-philosophy","title":"My philosophy","text":"<p>you don't know its capabilities until you break it</p>"},{"location":"coding/pascal-case/","title":"Pascal case vs Camel case","text":""},{"location":"coding/pascal-case/#pascalcase","title":"PascalCase","text":"<ul> <li>Capitalize start letter of every word.</li> <li>Eg: ThisIsPascalCase</li> </ul>"},{"location":"coding/pascal-case/#camelcase","title":"camelCase","text":"<ul> <li>Pascal case with lowercase start letter</li> <li>Eg: thisIsCamelCase</li> </ul>"},{"location":"coding/golang/is-for-loop-stills-good/","title":"Is for loop still good","text":""},{"location":"coding/golang/is-for-loop-stills-good/#question-on-vs-o1","title":"Question: O(n) vs O(1)","text":"<ul> <li>We all know that accessing a hashmap element costs O(1) of time and finding an element inside an array costs O(n) of time.</li> <li>But<ul> <li>O(1) is the hashing function cost </li> <li>O(n) is the number of elements</li> </ul> </li> <li>How large of an array must be, that the finding loop cost exceeds the cost of the hashing function?</li> </ul>"},{"location":"coding/golang/is-for-loop-stills-good/#benchmark-in-golang","title":"Benchmark in Golang","text":"<ul> <li>Code: https://github.com/thanhpp/gopher/blob/main/cmd/bench-hashmap/bench-hashmap_test.go</li> <li>Method: create slices and methods with different sizes, then choose a random number to search.</li> <li>Result</li> </ul> <pre><code>go test -bench=. -benchmem\ngoos: linux\ngoarch: amd64\npkg: github.com/thanhpp/gopher/bench-hashmap\ncpu: AMD Ryzen 5 5600G with Radeon Graphics\nBenchmarkSliceInt/size_1-12             125404327                9.605 ns/op           0 B/op          0 allocs/op\nBenchmarkSliceInt/size_5-12             69207064                17.54 ns/op            0 B/op          0 allocs/op\nBenchmarkSliceInt/size_10-12            63447366                18.60 ns/op            0 B/op          0 allocs/op\nBenchmarkSliceInt/size_20-12            58960952                20.43 ns/op            0 B/op          0 allocs/op\nBenchmarkSliceInt/size_30-12            54392230                21.73 ns/op            0 B/op          0 allocs/op\nBenchmarkSliceInt/size_40-12            53013524                23.26 ns/op            0 B/op          0 allocs/op\nBenchmarkSliceInt/size_50-12            49305501                24.35 ns/op            0 B/op          0 allocs/op\n\nBenchmarkMapInt/size_1-12               106518439               11.28 ns/op            0 B/op          0 allocs/op\nBenchmarkMapInt/size_5-12               67979809                18.07 ns/op            0 B/op          0 allocs/op\nBenchmarkMapInt/size_10-12              47070580                26.61 ns/op            0 B/op          0 allocs/op\nBenchmarkMapInt/size_20-12              45591961                26.35 ns/op            0 B/op          0 allocs/op\nBenchmarkMapInt/size_30-12              44955747                27.24 ns/op            0 B/op          0 allocs/op\nBenchmarkMapInt/size_40-12              46008104                25.74 ns/op            0 B/op          0 allocs/op\nBenchmarkMapInt/size_50-12              42991318                27.75 ns/op            0 B/op          0 allocs/op\n\nBenchmarkSliceString/size_1-12          94805643                12.54 ns/op            0 B/op          0 allocs/op\nBenchmarkSliceString/size_5-12          53173370                22.47 ns/op            0 B/op          0 allocs/op\nBenchmarkSliceString/size_10-12         42057357                28.63 ns/op            0 B/op          0 allocs/op\nBenchmarkSliceString/size_20-12         34653843                34.05 ns/op            0 B/op          0 allocs/op\nBenchmarkSliceString/size_30-12         28817215                41.65 ns/op            0 B/op          0 allocs/op\nBenchmarkSliceString/size_40-12         23304921                52.29 ns/op            0 B/op          0 allocs/op\nBenchmarkSliceString/size_50-12         19114158                62.58 ns/op            0 B/op          0 allocs/op\n\nBenchmarkMapString/size_1-12            93007335                13.08 ns/op            0 B/op          0 allocs/op\nBenchmarkMapString/size_5-12            52409577                23.35 ns/op            0 B/op          0 allocs/op\nBenchmarkMapString/size_10-12           42127460                26.81 ns/op            0 B/op          0 allocs/op\nBenchmarkMapString/size_20-12           39925528                30.12 ns/op            0 B/op          0 allocs/op\nBenchmarkMapString/size_30-12           43890310                27.75 ns/op            0 B/op          0 allocs/op\nBenchmarkMapString/size_40-12           39024145                31.18 ns/op            0 B/op          0 allocs/op\nBenchmarkMapString/size_50-12           37039489                32.53 ns/op            0 B/op          0 allocs/op\nPASS\nok      github.com/thanhpp/gopher/bench-hashmap 45.370s\n</code></pre> <ul> <li>Analytic: <ul> <li>The slice loop cost increases with the size of the slice (of course ^^).</li> <li>When the sizes are small enough (1, 5, 10): the cost of searching in a slice is cheaper.</li> <li>The cost of accessing a map in Golang is not a constant<ul> <li>When the size reaches a threshold, the cost increases significantly. (1 -&gt; 5/10)</li> <li>https://github.com/golang/go/blob/master/src/runtime/map.go</li> </ul> </li> <li>With different types<ul> <li>For slices, searching for integers is faster than searching for strings (which might be caused by the compare cost).</li> <li>For maps, searching for both types shows similar results.</li> </ul> </li> </ul> </li> </ul>"},{"location":"tools/docker/docker-compose-environment-quotes/","title":"Docker compose environment quotes","text":""},{"location":"tools/docker/docker-compose-environment-quotes/#docker-compose-environment-quotes","title":"Docker compose environment quotes","text":"<ul> <li>Do not use the <code>\"</code> mark in the docker-compose while setting the environment values.</li> <li>Docker compose adds the <code>\"</code> into ENV values<ul> <li>Eg: A=\"VALUE_A\", the application when reading the env A will get <code>\"VALUE_A\"</code> instead of <code>VALUE_A</code> </li> </ul> </li> </ul>"}]}